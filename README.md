# Queue SDK - PHP Event Messaging Library

<div align="center">
  
![PHP Version](https://img.shields.io/badge/php-%5E8.2-blue)
![License](https://img.shields.io/badge/license-MIT-green)
![Build Status](https://img.shields.io/badge/build-passing-brightgreen)
![Docker](https://img.shields.io/badge/docker-ready-blue)

**Uma biblioteca PHP moderna para consumo de eventos de mensageria com suporte a m√∫ltiplos provedores**

[Instala√ß√£o](#-instala√ß√£o) ‚Ä¢ [Uso B√°sico](#-uso-b√°sico) ‚Ä¢ [Laravel Integration](#-integra√ß√£o-com-laravel) ‚Ä¢ [Exemplos](#-exemplos-pr√°ticos) ‚Ä¢ [Docker](#-ambiente-docker)

</div>

## üéØ Vis√£o Geral

O **Queue SDK** √© uma biblioteca PHP que implementa uma abstra√ß√£o unificada para diferentes provedores de mensageria, seguindo os princ√≠pios da **Arquitetura Hexagonal** e **Event-Driven Architecture**.

### ‚ú® Caracter√≠sticas Principais

- üöÄ **Multi-Provider**: Apache Kafka + Amazon SQS + Extens√≠vel para Redis, RabbitMQ, Google Pub/Sub
- ‚ö° **High Performance**: Consumers otimizados com batch processing at√© 5,000 msg/s
- üèóÔ∏è **Arquitetura Hexagonal**: Separa√ß√£o clara entre dom√≠nio, aplica√ß√£o e infraestrutura  
- üéØ **Event-Driven**: Sistema flex√≠vel de estrat√©gias para processamento de eventos
- ÔøΩ **Docker Ready**: Ambiente completo com Kafka, SQS, Kafka UI
- üß™ **Test√°vel**: Cobertura completa de testes unit√°rios e integra√ß√£o
- üìã **Framework Agnostic**: Funciona com Laravel, Symfony ou PHP puro
- üîí **Type Safe**: PHP 8.2+ com strict types e valida√ß√£o robusta

## üì¶ Instala√ß√£o

```bash
composer require queue-sdk/queue-sdk
```

**üìñ Guia Completo:** Veja [INSTALL.md](INSTALL.md) para instru√ß√µes detalhadas, incluindo:
- Verifica√ß√£o autom√°tica de depend√™ncias
- Instala√ß√£o da extens√£o RdKafka (Kafka)
- Configura√ß√£o por sistema operacional
- Solu√ß√£o de problemas comuns

### Verifica√ß√£o R√°pida
```bash
composer run check-extensions
```

### Requisitos do Sistema

#### Obrigat√≥rios
- **PHP**: 8.2 ou superior
- **Extens√µes PHP**: 
  - `ext-json` (manipula√ß√£o JSON)
  - `ext-curl` (comunica√ß√£o HTTP)
  - `ext-openssl` (conex√µes seguras)
- **Composer**: Gerenciador de depend√™ncias PHP

#### Para Kafka (Produ√ß√£o)
- **Extens√£o PHP**: `ext-rdkafka` (comunica√ß√£o com Apache Kafka)
- **Biblioteca Sistema**: `librdkafka-dev` (biblioteca C do Kafka)

#### Para Desenvolvimento
- **Docker**: Ambiente de desenvolvimento com Kafka/SQS local
- **Git**: Controle de vers√£o

#### Instala√ß√£o da Extens√£o RdKafka (Produ√ß√£o)

```bash
# Ubuntu/Debian
sudo apt-get install librdkafka-dev
sudo pecl install rdkafka
echo "extension=rdkafka.so" >> /etc/php/8.2/cli/php.ini

# Alpine Linux (Docker)
apk add librdkafka-dev
pecl install rdkafka
docker-php-ext-enable rdkafka

# macOS
brew install librdkafka
pecl install rdkafka
```

## ÔøΩÔ∏è Scripts Utilit√°rios

O Queue SDK inclui scripts para facilitar desenvolvimento e demonstra√ß√µes:

### üöÄ Uso Simples
```bash
# Subir tudo de uma vez (containers + dashboard)
make up

# Acessar dashboard: http://localhost:8080
# Escolher um dos 6 cen√°rios pr√©-configurados
# Executar testes direto na interface web

# Derrubar tudo
make down
```

### üéØ Testes de Carga Otimizados
```bash
# Limpar resultados anteriores
make clean-tests

# Subir ambiente completo
make up

# Usar dashboard: http://localhost:8080
# Escolher entre 6 cen√°rios: Debug, Desenvolvimento, E-commerce, 
# Black Friday, IoT Sensores, Analytics
```

### üìã Comandos Dispon√≠veis
```bash
make help            # Lista todos os comandos dispon√≠veis
make up              # Subir ambiente completo (containers + dashboard)
make down            # Derrubar ambiente completo
make shell           # Acessa container PHP
make test            # Executa testes unit√°rios
make clean-tests     # Limpa arquivos de teste (JSON, logs)
make dashboard       # Iniciar apenas dashboard (se containers j√° est√£o up)
make demo            # Demo interativa completa
make setup-topics    # Configura t√≥picos Kafka otimizados
make clean           # Para containers e limpa volumes
make clean-all       # Limpeza completa (containers + tests)
```

> üìö **Documenta√ß√£o Completa**: [scripts/README.md](scripts/README.md)

## ÔøΩüöÄ Uso B√°sico

### 1. Configura√ß√£o Inicial

> **üìù Nota Importante**: O SDK **n√£o usa `.env`** - ele recebe configura√ß√£o via array PHP. 
> Configure no arquivo de configura√ß√£o do seu projeto (ex: `config/queue-sdk.php` no Laravel).

```php
<?php
// config/queue-sdk.php
return [
    'default_provider' => 'kafka', // ou 'sqs'
    
    'providers' => [
        'kafka' => [
            'brokers' => env('KAFKA_BROKERS', 'localhost:29092'),
            'group_id' => env('KAFKA_GROUP_ID', 'my-app-group'),
            'config' => [
                'max_batch_size' => 1000,
                'enable_compression' => true,
                'compression_type' => 'snappy',
                'fetch_min_bytes' => 100000,
                'retries' => 15,
                'acks' => 'all'
            ]
        ],
        'sqs' => [
            'queue_url' => env('SQS_QUEUE_URL'),
            'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),
            'endpoint' => env('SQS_ENDPOINT', null), // Para SQS local
            'credentials' => [
                'key' => env('AWS_ACCESS_KEY_ID'),
                'secret' => env('AWS_SECRET_ACCESS_KEY')
            ]
        ]
    ],
    
    'event_mappings' => [
        'user.created' => \App\Events\UserCreatedStrategy::class,
        'order.placed' => \App\Events\OrderPlacedStrategy::class,
        'payment.processed' => \App\Events\PaymentProcessedStrategy::class,
    ],
];
```

### 2. Criando Event Strategies

```php
<?php
// app/Events/UserCreatedStrategy.php

namespace App\Events;

use QueueSDK\Contracts\EventHandleInterface;
use QueueSDK\DTOs\ConsumerMessageQueueDTO;

class UserCreatedStrategy implements EventHandleInterface
{
    public function handle(ConsumerMessageQueueDTO $dto): void
    {
        $userData = $dto->getBody();
        
        // Valida√ß√£o
        if (empty($userData['user_id']) || empty($userData['email'])) {
            throw new \InvalidArgumentException('Missing required fields: user_id, email');
        }
        
        // Processamento do evento
        $this->sendWelcomeEmail($userData);
        $this->createUserProfile($userData);
        $this->updateAnalytics($userData);
        
        echo "‚úÖ User {$userData['user_id']} processed successfully\n";
    }
    
    private function sendWelcomeEmail(array $userData): void
    {
        // Integra√ß√£o com servi√ßo de email
        echo "üìß Sending welcome email to: {$userData['email']}\n";
    }
    
    private function createUserProfile(array $userData): void
    {
        // Criar perfil no banco de dados
        echo "üë§ Creating user profile for: {$userData['user_id']}\n";
    }
    
    private function updateAnalytics(array $userData): void
    {
        // Atualizar m√©tricas de analytics
        echo "üìä Updating analytics for user registration\n";
    }
}
```

### 3. Consumindo Eventos

#### Usando Factory Pattern (Recomendado)

```php
<?php
// app/Console/Commands/ConsumeEvents.php

use QueueSDK\QueueSDK;
use QueueSDK\Factories\EventStrategyFactory;

class ConsumeEventsCommand
{
    public function handle(string $topic): void
    {
        $config = require 'config/queue-sdk.php';
        
        // Inicializar SDK
        $sdk = new QueueSDK($config);
        $queue = $sdk->getQueue(); // Usa provider padr√£o
        
        echo "üöÄ Starting consumer for topic: {$topic}\n";
        
        while (true) {
            // Consumir mensagem
            $message = $queue->consume();
            
            if ($message === null) {
                usleep(100000); // 100ms
                continue;
            }
            
            try {
                // Resolver strategy baseada no t√≥pico
                $strategy = EventStrategyFactory::getStrategy($topic);
                
                if ($strategy === null) {
                    echo "‚ö†Ô∏è No strategy found for topic: {$topic}\n";
                    $queue->ack($message);
                    continue;
                }
                
                // Processar evento
                $strategy->handle($message);
                
                // Confirmar processamento
                $queue->ack($message);
                
                echo "‚úÖ Message processed successfully\n";
                
            } catch (\Throwable $e) {
                echo "‚ùå Error processing message: {$e->getMessage()}\n";
                $queue->nack($message);
            }
        }
    }
}
```

#### High-Performance Consumer

```php
<?php
// app/Console/Commands/HighPerformanceConsumer.php

use QueueSDK\Consumers\KafkaConsumer;
use QueueSDK\Queues\KafkaQueue;

class HighPerformanceConsumer
{
    public function consume(string $topic): void
    {
        $queue = new KafkaQueue(
            brokers: 'localhost:29092',
            topicName: $topic,
            groupId: 'high-perf-group',
            config: [
                'max_batch_size' => 1000,
                'enable_compression' => true,
                'fetch_min_bytes' => 100000,
                'retries' => 15
            ]
        );
        
        $consumer = new KafkaConsumer($queue);
        
        echo "üöÄ Starting high-performance consumer...\n";
        
        $consumer->consumeHighThroughput(
            batchSize: 1000,
            maxWaitTime: 5.0,
            callback: function (array $messages) use ($topic) {
                echo "üì¶ Processing batch of " . count($messages) . " messages\n";
                
                foreach ($messages as $message) {
                    $strategy = EventStrategyFactory::getStrategy($topic);
                    $strategy?->handle($message);
                }
                
                echo "‚úÖ Batch processed successfully\n";
            }
        );
    }
}
```

## üîß Integra√ß√£o com Laravel

### 1. Service Provider

```php
<?php
// app/Providers/QueueSDKServiceProvider.php

namespace App\Providers;

use Illuminate\Support\ServiceProvider;
use QueueSDK\QueueSDK;
use QueueSDK\Contracts\QueueInterface;

class QueueSDKServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        $this->app->singleton(QueueSDK::class, function ($app) {
            $config = config('queue-sdk');
            return new QueueSDK($config);
        });
        
        $this->app->bind(QueueInterface::class, function ($app) {
            return $app->make(QueueSDK::class)->getQueue();
        });
    }
    
    public function boot(): void
    {
        $this->publishes([
            __DIR__.'/../../config/queue-sdk.php' => config_path('queue-sdk.php'),
        ], 'queue-sdk-config');
    }
}
```

### 2. Comando Artisan

```php
<?php
// app/Console/Commands/QueueConsumeCommand.php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use QueueSDK\Contracts\QueueInterface;
use QueueSDK\Factories\EventStrategyFactory;

class QueueConsumeCommand extends Command
{
    protected $signature = 'queue:consume {topic : O t√≥pico para consumir}';
    protected $description = 'Consume messages from queue';
    
    public function handle(QueueInterface $queue): void
    {
        $topic = $this->argument('topic');
        
        $this->info("üöÄ Starting consumer for topic: {$topic}");
        
        while (true) {
            $message = $queue->consume();
            
            if ($message === null) {
                usleep(100000);
                continue;
            }
            
            try {
                $strategy = EventStrategyFactory::getStrategy($topic);
                
                if ($strategy === null) {
                    $this->warn("No strategy found for topic: {$topic}");
                    $queue->ack($message);
                    continue;
                }
                
                $strategy->handle($message);
                $queue->ack($message);
                
                $this->info("‚úÖ Message processed");
                
            } catch (\Throwable $e) {
                $this->error("‚ùå Error: {$e->getMessage()}");
                $queue->nack($message);
            }
        }
    }
}
```

### 3. Publicando Eventos

```php
<?php
// app/Services/EventPublisher.php

namespace App\Services;

use QueueSDK\Contracts\QueueInterface;
use QueueSDK\DTOs\PublishMessageQueueDTO;

class EventPublisher
{
    public function __construct(
        private QueueInterface $queue
    ) {}
    
    public function publishUserCreated(int $userId, string $email): void
    {
        $message = new PublishMessageQueueDTO([
            'body' => [
                'user_id' => $userId,
                'email' => $email,
                'created_at' => now()->toISOString()
            ],
            'topic' => 'user.created',
            'key' => (string) $userId,
            'headers' => [
                'EventType' => 'UserCreated',
                'Version' => '1.0',
                'Source' => 'user-service'
            ]
        ]);
        
        $this->queue->publish($message);
    }
}
```

## üê≥ Ambiente Docker

### Servi√ßos Dispon√≠veis

O SDK inclui ambiente Docker completo com:

- **Apache Kafka**: Streaming de alta performance (KRaft mode)
- **SQS Local**: ElasticMQ para desenvolvimento
- **Kafka UI**: Interface web para monitoramento
- **PHP 8.2**: Container de desenvolvimento

### Comandos Docker

```bash
# Iniciar ambiente completo
make dev

# Executar testes
make test

# Acessar container PHP
make shell

# Ver logs dos servi√ßos
make logs

# Status dos containers
make status

# Limpar ambiente
make clean
```

### URLs dos Servi√ßos

- **Kafka UI**: http://localhost:8083
- **SQS Web**: http://localhost:9325
- **SQS API**: http://localhost:9324
- **Kafka**: `localhost:29092` (externo), `kafka:9092` (interno)

## üìã Exemplos Pr√°ticos

### E-commerce: Processamento de Pedidos

```php
<?php
// Estrat√©gia para processar pedidos
class OrderPlacedStrategy implements EventHandleInterface
{
    public function handle(ConsumerMessageQueueDTO $dto): void
    {
        $orderData = $dto->getBody();
        
        // Valida√ß√£o
        $this->validateOrderData($orderData);
        
        // Processamento em paralelo
        $this->reserveInventory($orderData['items']);
        $this->processPayment($orderData['payment']);
        $this->sendOrderConfirmation($orderData['customer']);
        $this->updateAnalytics($orderData);
        
        logger()->info('Order processed', ['order_id' => $orderData['order_id']]);
    }
    
    private function validateOrderData(array $data): void
    {
        $required = ['order_id', 'customer', 'items', 'payment'];
        
        foreach ($required as $field) {
            if (empty($data[$field])) {
                throw new \InvalidArgumentException("Missing field: {$field}");
            }
        }
    }
}
```

### IoT: Processamento de Sensores

```php
<?php
// High-throughput para dados de sensores
class SensorDataStrategy implements EventHandleInterface
{
    private array $batchBuffer = [];
    private const BATCH_SIZE = 100;
    
    public function handle(ConsumerMessageQueueDTO $dto): void
    {
        $sensorData = $dto->getBody();
        
        // Adicionar ao buffer de batch
        $this->batchBuffer[] = [
            'sensor_id' => $sensorData['sensor_id'],
            'value' => $sensorData['value'],
            'timestamp' => $sensorData['timestamp'],
            'location' => $sensorData['location'] ?? null
        ];
        
        // Processar quando o batch estiver cheio
        if (count($this->batchBuffer) >= self::BATCH_SIZE) {
            $this->processBatch();
            $this->batchBuffer = [];
        }
    }
    
    private function processBatch(): void
    {
        // Inser√ß√£o em lote no banco
        DB::table('sensor_readings')->insert($this->batchBuffer);
        
        // An√°lise em tempo real
        $this->detectAnomalies($this->batchBuffer);
        
        echo "üìä Processed batch of " . count($this->batchBuffer) . " sensor readings\n";
    }
}
```

### Microservi√ßos: Event Sourcing

```php
<?php
// Event sourcing pattern
class EventSourcingStrategy implements EventHandleInterface
{
    public function handle(ConsumerMessageQueueDTO $dto): void
    {
        $event = $dto->getBody();
        
        // Armazenar evento no event store
        $this->storeEvent($event);
        
        // Atualizar proje√ß√µes (read models)
        $this->updateProjections($event);
        
        // Replicar para outros servi√ßos se necess√°rio
        if ($this->shouldReplicate($event)) {
            $this->replicateToServices($event);
        }
    }
    
    private function storeEvent(array $event): void
    {
        EventStore::create([
            'aggregate_id' => $event['aggregate_id'],
            'event_type' => $event['event_type'],
            'event_data' => $event['data'],
            'version' => $event['version'],
            'occurred_at' => $event['timestamp']
        ]);
    }
}
```

## üéØ Performance e Benchmarks

### Throughput por Consumer Type

| Consumer Type | Throughput | Uso Recomendado |
|---------------|------------|-----------------|
| AbstractQueueConsumer | 100-300 msg/s | Desenvolvimento, prototipagem |
| SQS Consumer | 200-500 msg/s | Aplica√ß√µes com SQS |
| Kafka Consumer | 2,000-5,000 msg/s | High-throughput, streaming |
| Batch Consumer | 10,000+ msg/s | Processamento em lote |

### Configura√ß√µes de Performance

```php
// Alta performance para Kafka
$config = [
    'max_batch_size' => 1000,
    'enable_compression' => true,
    'compression_type' => 'snappy',
    'linger_ms' => 20,
    'fetch_min_bytes' => 100000,
    'fetch_max_wait_ms' => 500,
    'retries' => 15,
    'acks' => 'all'
];

// Otimiza√ß√£o para SQS
$config = [
    'max_batch_size' => 10, // Limite do SQS
    'visibility_timeout' => 60,
    'wait_time_seconds' => 20,
    'receive_message_attributes' => ['All']
];
```
## üéØ Projeto de Exemplo Real

### Demonstra√ß√£o Pr√°tica com Alta Demanda

Inclu√≠mos um **projeto completo de exemplo** no diret√≥rio `example-project/` que demonstra como usar o Queue SDK em cen√°rios reais de **alta demanda**.

```bash
# Acessar projeto de exemplo
cd example-project

# Executar testes das Event Strategies
php test-strategies.php

# Produzir eventos em massa (1000 pedidos/s)
php producer.php order.placed 10000 100

# Consumer de alta performance
php consumer.php order.placed high-performance
```

### üèóÔ∏è Estrutura do Projeto de Exemplo

```
example-project/
‚îú‚îÄ‚îÄ app/Events/
‚îÇ   ‚îú‚îÄ‚îÄ UserCreatedStrategy.php      # Processa registro de usu√°rios
‚îÇ   ‚îî‚îÄ‚îÄ OrderPlacedStrategy.php      # Processa pedidos (batch otimizado)
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ queue-sdk.php                # Configura√ß√£o completa
‚îú‚îÄ‚îÄ consumer.php                     # Consumer com 3 modos
‚îú‚îÄ‚îÄ producer.php                     # Producer para testes de carga
‚îú‚îÄ‚îÄ test-strategies.php             # Testes das strategies
‚îî‚îÄ‚îÄ README.md                       # Documenta√ß√£o detalhada
```

### üöÄ Cen√°rios de Teste Inclu√≠dos

#### 1. E-commerce: Black Friday Simulation
```bash
# Simular pico de pedidos (33 msg/s por 5 minutos)
php producer.php order.placed 10000 33

# Consumer otimizado para picos
php consumer.php order.placed high-performance
```

#### 2. User Registration Campaign
```bash
# 5000 usu√°rios em massa
php producer.php user.created 5000 20

# Processamento completo de onboarding
php consumer.php user.created batch
```

#### 3. IoT Sensor Data (Customiz√°vel)
```bash
# Alta frequ√™ncia de dados
php producer.php sensor.reading 50000 100

# Processing de alt√≠ssima performance
php consumer.php sensor.reading high-performance
```

### üìä Performance Benchmarks Reais

| Cen√°rio | Producer | Consumer | Throughput Total |
|---------|----------|----------|------------------|
| **UserCreated** (Onboarding completo) | 20 msg/s | 300-500 msg/s | ~500 msg/s |
| **OrderPlaced** (E-commerce individual) | 50 msg/s | 1,000-2,000 msg/s | ~2,000 msg/s |
| **OrderPlaced** (Batch otimizado) | 100 msg/s | 3,000-5,000 msg/s | ~5,000 msg/s |
| **High-Performance Mode** | 200+ msg/s | 10,000+ msg/s | ~10,000+ msg/s |

### üîß Event Strategies Implementadas

#### UserCreatedStrategy
- **Opera√ß√µes**: Email boas-vindas, perfil, prefer√™ncias, analytics, marketing
- **Valida√ß√£o**: Email format, campos obrigat√≥rios
- **Performance**: ~300-500 msg/s

#### OrderPlacedStrategy  
- **Opera√ß√µes**: Invent√°rio, pagamento, cliente, envio
- **Otimiza√ß√µes**: Batch processing autom√°tico (50 pedidos/batch)
- **Performance**: ~1,000-5,000 msg/s (modo batch)

Veja `example-project/README.md` para **instru√ß√µes detalhadas** e **mais cen√°rios de teste**!

## üöÄ Deployment

### Produ√ß√£o com Docker

```dockerfile
# Dockerfile para produ√ß√£o
FROM php:8.2-fpm-alpine

# Instalar extens√µes necess√°rias
RUN apk add --no-cache \
    librdkafka-dev \
    && docker-php-ext-install \
    pdo_mysql \
    && pecl install rdkafka \
    && docker-php-ext-enable rdkafka

COPY . /app
WORKDIR /app

RUN composer install --no-dev --optimize-autoloader

CMD ["php", "consumer.php"]
```

### Kubernetes Deployment

```yaml
# k8s/consumer-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: queue-consumer
spec:
  replicas: 3
  selector:
    matchLabels:
      app: queue-consumer
  template:
    metadata:
      labels:
        app: queue-consumer
    spec:
      containers:
      - name: consumer
        image: your-registry/queue-consumer:latest
        env:
        - name: KAFKA_BROKERS
          value: "kafka-service:9092"
        - name: KAFKA_GROUP_ID
          value: "production-group"
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi
```

## üìö Documenta√ß√£o Adicional

- **Exemplo Completo**: Confira o diret√≥rio `example-project/` para um projeto funcional
- **Estrat√©gias de Eventos**: Veja `example-project/app/Events/` para exemplos reais
- **Configura√ß√£o**: Arquivo `example-project/config/queue-sdk.php` para refer√™ncia
- **Testes**: Execute `make test` para validar funcionamento

## ü§ù Contribui√ß√£o

Contribui√ß√µes s√£o bem-vindas! Por favor, leia nosso [guia de contribui√ß√£o](CONTRIBUTING.md).

### Processo de Desenvolvimento

1. Fork o projeto
2. Crie uma branch para sua feature (`git checkout -b feature/nova-funcionalidade`)
3. Fa√ßa commit das mudan√ßas (`git commit -am 'Adiciona nova funcionalidade'`)
4. Push para a branch (`git push origin feature/nova-funcionalidade`)
5. Abra um Pull Request

### Padr√µes de C√≥digo

- PSR-12 para style
- PHPStan level 8
- Cobertura de testes > 90%
- Documenta√ß√£o obrigat√≥ria

## üìù Licen√ßa

Este projeto est√° licenciado sob a Licen√ßa MIT - veja o arquivo [LICENSE](LICENSE) para detalhes.

## üÜò Suporte

- üìß **Email**: support@queue-sdk.com
- üí¨ **Discord**: [Queue SDK Community](https://discord.gg/queue-sdk)
- üêõ **Issues**: [GitHub Issues](https://github.com/your-username/queue-sdk/issues)
- üìñ **Docs**: [Documenta√ß√£o Completa](https://docs.queue-sdk.com)

---

<div align="center">

**Feito com ‚ù§Ô∏è para a comunidade PHP**

[‚≠ê Star no GitHub](https://github.com/your-username/queue-sdk) ‚Ä¢ [üê¶ Seguir no Twitter](https://twitter.com/queue_sdk) ‚Ä¢ [üì± LinkedIn](https://linkedin.com/company/queue-sdk)

</div>
    
    private function createUserProfile(array $userData): void
    {
        // Criar perfil do usu√°rio
        echo "Creating profile for user: " . $userData['user_id'] . PHP_EOL;
    }
    
    private function trackUserRegistration(array $userData): void
    {
        // Rastreamento para analytics
        echo "Tracking registration for user: " . $userData['user_id'] . PHP_EOL;
    }
}

class OrderPlacedStrategy extends AbstractEventStrategy
{
    protected function process(ConsumerMessageDTO $dto): void
    {
        $orderData = $dto->getBody();
        
        // Processar pedido
        $this->updateInventory($orderData);
        $this->notifyWarehouse($orderData);
        $this->sendOrderConfirmation($orderData);
    }
    
    private function updateInventory(array $orderData): void
    {
        echo "Updating inventory for order: " . $orderData['order_id'] . PHP_EOL;
    }
    
    private function notifyWarehouse(array $orderData): void
    {
        echo "Notifying warehouse for order: " . $orderData['order_id'] . PHP_EOL;
    }
    
    private function sendOrderConfirmation(array $orderData): void
    {
        echo "Sending confirmation for order: " . $orderData['order_id'] . PHP_EOL;
    }
}
```

### 3. Consumindo Eventos (Performance Otimizada)

```php
<?php

require 'vendor/autoload.php';

use QueueSDK\Queues\HighPerformanceKafkaQueue;
use QueueSDK\Consumers\OptimizedQueueConsumer;
use QueueSDK\Factories\EventStrategyFactory;

// Carregar configura√ß√£o
$config = require 'config/queue-sdk.php';

// Usar consumer otimizado (recomendado)
$queue = new HighPerformanceKafkaQueue($config['queues']['kafka']);
$factory = new EventStrategyFactory($config['topic_mappings']);

$consumer = new OptimizedQueueConsumer($queue, $factory);

// Configurar performance
$consumer->setBatchSize(50)              // Processar 50 mensagens por vez
         ->setMaxProcessingTime(30)      // Timeout de 30s por batch
         ->enableCircuitBreaker()        // Prote√ß√£o contra falhas
         ->setWorkerCount(4);           // 4 workers paralelos

echo "Starting optimized consumer..." . PHP_EOL;
$consumer->consumeWithFactory('user.created');
```

### Consumindo com Diferentes Provedores

```php
// Para Kafka de alta performance
$kafkaQueue = new HighPerformanceKafkaQueue([
    'brokers' => 'localhost:9092',
    'group_id' => 'high-perf-group',
    'topic' => 'events',
    'consumer_timeout_ms' => 1000,
    'enable_auto_commit' => false
]);

$kafkaConsumer = new KafkaConsumer($kafkaQueue, $factory);
$kafkaConsumer->setBatchSize(100)->setCommitInterval(10);

// Para SQS
$sqsQueue = new SqsQueue($config['queues']['sqs']);
$sqsConsumer = new SqsConsumer($sqsQueue, $factory);
$sqsConsumer->setBatchSize(10)->setVisibilityTimeout(300);

// Consumir
$kafkaConsumer->consumeWithFactory('high-volume-events');
$sqsConsumer->consumeWithFactory('user.created');
```

// Ou consumir m√∫ltiplos t√≥picos
/*
$topics = ['user.created', 'order.placed', 'payment.processed'];
foreach ($topics as $topic) {
    $consumer->consumeWithFactory($topic);
}
*/
```

### 4. Publicando Eventos

```php
<?php

use QueueSDK\DTOs\PublishMessageDTO;
use QueueSDK\Queues\SqsQueue;

$queue = new SqsQueue($config['queues']['sqs']);

// Publicar evento de usu√°rio criado
$userEvent = new PublishMessageDTO([
    'body' => [
        'user_id' => 12345,
        'email' => 'user@example.com',
        'name' => 'Jo√£o Silva',
        'created_at' => date('Y-m-d H:i:s')
    ],
    'headers' => [
        'EventType' => 'user.created',
        'Source' => 'user-service',
        'Version' => '1.0'
    ]
]);

$queue->publish($userEvent);
echo "User created event published!" . PHP_EOL;

// Publicar evento de pedido
$orderEvent = new PublishMessageDTO([
    'body' => [
        'order_id' => 'ORD-789',
        'user_id' => 12345,
        'total' => 299.99,
        'items' => [
            ['product_id' => 'PROD-1', 'quantity' => 2, 'price' => 149.99]
        ]
    ],
    'headers' => [
        'EventType' => 'order.placed',
        'Source' => 'order-service',
        'Version' => '1.0'
    ]
]);

$queue->publish($orderEvent);
echo "Order placed event published!" . PHP_EOL;
```

## üîå Provedores Suportados

### Amazon SQS

```php
use QueueSDK\Queues\SqsQueue;

$sqsQueue = new SqsQueue([
    'queue_url' => 'https://sqs.us-east-1.amazonaws.com/123456789/my-queue',
    'region' => 'us-east-1',
    'credentials' => [
        'key' => 'AKIA...',
        'secret' => 'your-secret-key'
    ],
    'max_messages' => 1,
    'wait_time' => 20,
    'visibility_timeout' => 30
]);
```

### Apache Kafka

```php
use QueueSDK\Queues\KafkaQueue;

$kafkaQueue = new KafkaQueue([
    'brokers' => 'localhost:9092',
    'group_id' => 'my-consumer-group',
    'topic' => 'events-topic',
    'timeout' => 30000,
    'auto_offset_reset' => 'earliest'
]);
```

## üéØ Extensibilidade

### Adicionando Novo Provedor (Redis)

```php
<?php

namespace App\Queues;

use QueueSDK\Queues\AbstractQueue;
use QueueSDK\DTOs\ConsumerMessageDTO;
use QueueSDK\DTOs\PublishMessageDTO;

class RedisQueue extends AbstractQueue
{
    private \Redis $redis;
    
    public function __construct(array $config)
    {
        $this->redis = new \Redis();
        $this->redis->connect($config['host'], $config['port']);
        
        if (isset($config['password'])) {
            $this->redis->auth($config['password']);
        }
    }
    
    public function consume(): ?ConsumerMessageDTO
    {
        // Consumir de uma lista Redis com timeout
        $result = $this->redis->blpop(['queue:events'], 30);
        
        if (!$result) {
            return null;
        }
        
        $messageData = json_decode($result[1], true);
        
        return new ConsumerMessageDTO([
            'body' => $messageData['body'] ?? [],
            'headers' => $messageData['headers'] ?? [],
            'message_id' => $messageData['id'] ?? uniqid(),
            'receipt_handle' => $result[1] // Para NACK, re-adicionar √† fila
        ]);
    }
    
    public function publish(PublishMessageDTO $dto): void
    {
        $message = json_encode([
            'id' => uniqid(),
            'body' => $dto->getBody(),
            'headers' => $dto->getHeaders(),
            'timestamp' => time()
        ]);
        
        $this->redis->rpush('queue:events', $message);
    }
    
    public function ack(ConsumerMessageDTO $dto): void
    {
        // Redis n√£o requer ACK expl√≠cito para BLPOP
        // Mensagem j√° foi removida da fila
    }
    
    public function nack(ConsumerMessageDTO $dto): void
    {
        // Reprocessar: adicionar de volta √† fila
        $this->redis->lpush('queue:events', $dto->getReceiptHandle());
    }
}
```

### Usando o Novo Provedor

```php
$redisQueue = new App\Queues\RedisQueue([
    'host' => 'localhost',
    'port' => 6379,
    'password' => 'your-redis-password' // opcional
]);

$consumer = new MyQueueConsumer($redisQueue, $factory);
$consumer->consumeWithFactory('user.created');
```

## üèóÔ∏è Arquitetura

O SDK segue a **Arquitetura Hexagonal** com separa√ß√£o clara de responsabilidades:

```
src/
‚îú‚îÄ‚îÄ Contracts/          # Domain Layer - Interfaces e contratos
‚îÇ   ‚îú‚îÄ‚îÄ QueueInterface.php
‚îÇ   ‚îî‚îÄ‚îÄ EventHandleInterface.php
‚îú‚îÄ‚îÄ DTOs/               # Application Layer - Data Transfer Objects
‚îÇ   ‚îú‚îÄ‚îÄ ConsumerMessageDTO.php
‚îÇ   ‚îî‚îÄ‚îÄ PublishMessageDTO.php
‚îú‚îÄ‚îÄ Queues/             # Infrastructure Layer - Implementa√ß√µes de filas
‚îÇ   ‚îú‚îÄ‚îÄ AbstractQueue.php
‚îÇ   ‚îú‚îÄ‚îÄ SqsQueue.php
‚îÇ   ‚îî‚îÄ‚îÄ KafkaQueue.php
‚îú‚îÄ‚îÄ Strategies/         # Application Layer - Estrat√©gias de eventos
‚îÇ   ‚îú‚îÄ‚îÄ AbstractEventStrategy.php
‚îÇ   ‚îî‚îÄ‚îÄ ExampleEventStrategy.php
‚îú‚îÄ‚îÄ Factories/          # Application Layer - Factories
‚îÇ   ‚îî‚îÄ‚îÄ EventStrategyFactory.php
‚îú‚îÄ‚îÄ Consumers/          # Application Layer - Consumers
‚îÇ   ‚îî‚îÄ‚îÄ AbstractQueueConsumer.php
‚îî‚îÄ‚îÄ Exceptions/         # Domain Layer - Exce√ß√µes customizadas
    ‚îî‚îÄ‚îÄ QueueException.php
```

### Princ√≠pios Aplicados

- **Dependency Inversion**: Dependa de abstra√ß√µes, n√£o de implementa√ß√µes concretas
- **Open/Closed**: Aberto para extens√£o, fechado para modifica√ß√£o
- **Single Responsibility**: Uma responsabilidade por classe
- **Interface Segregation**: Interfaces pequenas e espec√≠ficas

## üß™ Desenvolvimento e Testes

### Executar Testes

```bash
# Todos os testes
docker-compose run --rm queue-sdk-test

# Apenas testes unit√°rios
docker-compose run --rm queue-sdk-test vendor/bin/phpunit --testsuite=Unit

# Testes com coverage
docker-compose run --rm queue-sdk-test vendor/bin/phpunit --coverage-html coverage
```

### Estrutura de Testes

```
tests/
‚îú‚îÄ‚îÄ Unit/               # Testes unit√°rios (r√°pidos, isolados)
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/           # Testes para DTOs
‚îÇ   ‚îú‚îÄ‚îÄ Strategies/     # Testes para estrat√©gias
‚îÇ   ‚îú‚îÄ‚îÄ Queues/         # Testes para filas
‚îÇ   ‚îî‚îÄ‚îÄ Factories/      # Testes para factories
‚îú‚îÄ‚îÄ Integration/        # Testes de integra√ß√£o (SQS, Kafka reais)
‚îî‚îÄ‚îÄ Feature/           # Testes end-to-end (workflows completos)
```

### Executar Exemplo

```bash
# Executar exemplo de consumer
make shell
cd example-project
php consumer.php user-created batch

# Ou testar producer de alta demanda
cd example-project  
php producer.php user-created 1000 10
```

## üîß Comandos Docker √öteis

```bash
# Desenvolvimento
docker-compose up -d queue-sdk-dev        # Iniciar ambiente
docker-compose exec queue-sdk-dev bash    # Acessar container
docker-compose down                        # Parar containers

# Testes
docker-compose run --rm queue-sdk-test     # Executar todos os testes
docker-compose run --rm queue-sdk-test vendor/bin/phpunit --testsuite=Unit

# Kafka (para testes de integra√ß√£o)
docker-compose up -d kafka zookeeper      # Iniciar Kafka
docker-compose exec kafka bash            # Acessar container Kafka

# Verificar code style
docker-compose run --rm queue-sdk-dev composer cs-check
docker-compose run --rm queue-sdk-dev composer cs-fix

# Instalar depend√™ncias
docker-compose run --rm queue-sdk-dev composer install
```

## üìö Exemplos Avan√ßados

### Processamento com Retry e Error Handling

```php
<?php

class RobustEventStrategy extends AbstractEventStrategy
{
    private int $maxRetries = 3;
    
    protected function process(ConsumerMessageDTO $dto): void
    {
        $retryCount = 0;
        
        while ($retryCount < $this->maxRetries) {
            try {
                $this->processWithRetry($dto);
                return; // Sucesso, sair do loop
                
            } catch (\Exception $e) {
                $retryCount++;
                
                if ($retryCount >= $this->maxRetries) {
                    $this->handleFinalError($dto, $e);
                    throw $e;
                }
                
                $this->log('warning', 'Retry attempt', [
                    'attempt' => $retryCount,
                    'error' => $e->getMessage()
                ]);
                
                sleep(pow(2, $retryCount)); // Exponential backoff
            }
        }
    }
    
    private function processWithRetry(ConsumerMessageDTO $dto): void
    {
        // Sua l√≥gica de processamento que pode falhar
        $data = $dto->getBody();
        
        // Simular falha aleat√≥ria
        if (rand(1, 3) === 1) {
            throw new \Exception('Random processing error');
        }
        
        echo "Processing message: " . json_encode($data) . PHP_EOL;
    }
    
    private function handleFinalError(ConsumerMessageDTO $dto, \Exception $e): void
    {
        // Enviar para dead letter queue ou log de erro
        $this->log('error', 'Message processing failed after all retries', [
            'message' => $dto->getBody(),
            'error' => $e->getMessage()
## üöÄ Comandos de Exemplo

Execute os exemplos pr√°ticos para testar o SDK:

```bash
# Exemplo b√°sico de uso
make example

# Teste de carga com Kafka (Alta Performance)
make load-test

# Teste espec√≠fico do Kafka
make kafka-example

# Demonstra√ß√£o de consumers otimizados
make optimized-consumers

# Executar todos os testes
make test

# Entrar no container para desenvolvimento
make shell
```

## üéØ Exemplos Pr√°ticos

### `example-project/` - Projeto Completo
- **Producer/Consumer Funcionais**: Scripts reais para testes de alta demanda
- **Event Strategies**: `UserCreatedStrategy` e `OrderPlacedStrategy` 
- **Configura√ß√£o Real**: Kafka + SQS configurados
- **Testes de Performance**: Suporte a milhares de msgs/segundo

### Scripts Dispon√≠veis
```bash
# Producer de alta demanda
php producer.php user-created 1000 10  # 1000 msgs com 10ms intervalo

# Consumer otimizado (batch)
php consumer.php user-created batch    # Processa em lotes

# Consumer single
php consumer.php order-placed single   # Processa uma por vez

# Setup de t√≥picos Kafka
./scripts/setup-kafka-topics.sh               # Cria t√≥picos otimizados
```
        echo "Worker #{$workerId} started for topic: {$topic}" . PHP_EOL;
        
        while (true) {
            try {
                $this->consumeWithFactory($topic);
                usleep(100000); // 100ms entre verifica√ß√µes
            } catch (\Exception $e) {
                echo "Worker #{$workerId} error: " . $e->getMessage() . PHP_EOL;
                sleep(1); // Aguardar antes de tentar novamente
            }
        }
    }
}
```

## ü§ù Contribuindo

1. Fork o reposit√≥rio
2. Crie uma branch para sua feature: `git checkout -b feature/nova-funcionalidade`
3. Desenvolva usando Docker: `docker-compose exec queue-sdk-dev bash`
4. Execute os testes: `docker-compose run --rm queue-sdk-test`
5. Commit suas mudan√ßas: `git commit -m 'feat: adiciona nova funcionalidade'`
6. Push para a branch: `git push origin feature/nova-funcionalidade`
7. Abra um Pull Request

### Padr√µes de Commit

- `feat:` Nova funcionalidade
- `fix:` Corre√ß√£o de bug
- `docs:` Documenta√ß√£o
- `style:` Formata√ß√£o
- `refactor:` Refatora√ß√£o
- `test:` Testes
- `chore:` Manuten√ß√£o

## üìÑ Licen√ßa

Este projeto est√° licenciado sob a [MIT License](LICENSE).

---

<div align="center">

**Feito com ‚ù§Ô∏è para a comunidade PHP**

</div>
